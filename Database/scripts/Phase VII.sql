--phase VII

CREATE TABLE public_holidays (
    holiday_date DATE PRIMARY KEY,
    description  VARCHAR2(200)
);
INSERT INTO public_holidays (holiday_date, description)
VALUES (DATE '2025-01-01', 'New Year’s Day');

INSERT INTO public_holidays (holiday_date, description)
VALUES (DATE '2025-02-01', 'National Heroes Day');

INSERT INTO public_holidays (holiday_date, description)
VALUES (DATE '2025-04-07', 'Genocide Memorial Day');

INSERT INTO public_holidays (holiday_date, description)
VALUES (DATE '2025-04-18', 'Good Friday');

INSERT INTO public_holidays (holiday_date, description)
VALUES (DATE '2025-04-21', 'Easter Monday');

INSERT INTO public_holidays (holiday_date, description)
VALUES (DATE '2025-05-01', 'Labor Day');

INSERT INTO public_holidays (holiday_date, description)
VALUES (DATE '2025-07-01', 'Independence Day');

INSERT INTO public_holidays (holiday_date, description)
VALUES (DATE '2025-07-04', 'Liberation Day');

INSERT INTO public_holidays (holiday_date, description)
VALUES (DATE '2025-08-01', 'Umuganura Day');

INSERT INTO public_holidays (holiday_date, description)
VALUES (DATE '2025-08-15', 'Assumption Day');

INSERT INTO public_holidays (holiday_date, description)
VALUES (DATE '2025-12-25', 'Christmas Day');

INSERT INTO public_holidays (holiday_date, description)
VALUES (DATE '2025-12-26', 'Boxing Day');

COMMIT;

Step 2 — Create Audit Log Table

CREATE TABLE action_audit (
    audit_id        NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    username        VARCHAR2(100),
    action_type     VARCHAR2(20),   -- INSERT, UPDATE, DELETE
    table_name      VARCHAR2(50),
    action_time     TIMESTAMP,
    allowed         VARCHAR2(10),   -- 'YES' or 'NO'
    reason          VARCHAR2(200)   -- If blocked, explain why
);

Step 3 — Audit Logging Function

CREATE OR REPLACE FUNCTION is_operation_allowed
RETURN VARCHAR2
AS
    v_day NUMBER := TO_NUMBER(TO_CHAR(SYSDATE, 'D'));  
    v_holiday NUMBER;
BEGIN
    -- Check holiday
    SELECT COUNT(*) INTO v_holiday
    FROM public_holidays
    WHERE holiday_date = TRUNC(SYSDATE);

    IF v_holiday > 0 THEN
        RETURN 'HOLIDAY';
    END IF;

    -- Check weekday
    -- Sunday = 1, Monday = 2 ... depending on NLS settings
    IF v_day BETWEEN 2 AND 6 THEN   -- Monday–Friday
        RETURN 'WEEKDAY';
    END IF;

    RETURN 'OK'; -- allowed
END;

Step 4 — Restriction Check Function

This function determines YES/NO: Is the action allowed?

CREATE OR REPLACE FUNCTION is_operation_allowed
RETURN VARCHAR2
AS
    v_day NUMBER := TO_NUMBER(TO_CHAR(SYSDATE, 'D'));  
    v_holiday NUMBER;
BEGIN
    -- Check holiday
    SELECT COUNT(*) INTO v_holiday
    FROM public_holidays
    WHERE holiday_date = TRUNC(SYSDATE);

    IF v_holiday > 0 THEN
        RETURN 'HOLIDAY';
    END IF;

    -- Check weekday
    -- Sunday = 1, Monday = 2 ... depending on NLS settings
    IF v_day BETWEEN 2 AND 6 THEN   -- Monday–Friday
        RETURN 'WEEKDAY';
    END IF;

    RETURN 'OK'; -- allowed
END;

Step 5 — Simple BEFORE Trigger (Blocks Operations)

create or replace TRIGGER trg_sales_restrictions
BEFORE INSERT OR UPDATE OR DELETE ON sales_history
FOR EACH ROW
DECLARE
    v_check VARCHAR2(50);
    v_action VARCHAR2(20);
BEGIN
    -- Detect the action type
    IF INSERTING THEN
        v_action := 'INSERT';
    ELSIF UPDATING THEN
        v_action := 'UPDATE';
    ELSIF DELETING THEN
        v_action := 'DELETE';
    END IF;

    -- Call your rule-validation function
    v_check := is_operation_allowed();   -- FIXED

    -- If blocked
    IF v_check <> 'OK' THEN
        log_action(
            p_user    => SYS_CONTEXT('USERENV','SESSION_USER'),
            p_action  => v_action,
            p_table   => 'SALES_HISTORY',
            p_allowed => 'NO',
            p_reason  => v_check
        );

        RAISE_APPLICATION_ERROR(-20001, 'Operation blocked: ' || v_check);
    END IF;

    -- If allowed
    log_action(
        p_user    => SYS_CONTEXT('USERENV','SESSION_USER'),
        p_action  => v_action,
        p_table   => 'SALES_HISTORY',
        p_allowed => 'YES',
        p_reason  => 'Allowed'
    );

END;

step 6 OMPOUND TRIGGER FOR SALES_HISTORY

--OMPOUND TRIGGER FOR SALES_HISTORY
CREATE OR REPLACE TRIGGER trg_sales_history_compound
FOR INSERT OR UPDATE OR DELETE ON sales_history
COMPOUND TRIGGER

    -- Global variables for tracking results
    v_check      VARCHAR2(50);
    v_allowed    VARCHAR2(3);
    v_action     VARCHAR2(20);

    TYPE t_row_changes IS TABLE OF VARCHAR2(100);
    changed_rows t_row_changes := t_row_changes();

BEFORE STATEMENT IS
BEGIN
    -- Evaluate restriction rule once per statement
    v_check := is_operation_allowed();

    IF v_check = 'OK' THEN
        v_allowed := 'YES';
    ELSE
        v_allowed := 'NO';
    END IF;
END BEFORE STATEMENT;


BEFORE EACH ROW IS
BEGIN
    -- Identify action
    IF INSERTING THEN
        v_action := 'INSERT';
    ELSIF UPDATING THEN
        v_action := 'UPDATE';
    ELSIF DELETING THEN
        v_action := 'DELETE';
    END IF;

    -- If operation is blocked → stop here
    IF v_allowed = 'NO' THEN
        log_action(
            p_user    => SYS_CONTEXT('USERENV','SESSION_USER'),
            p_action  => v_action,
            p_table   => 'SALES_HISTORY',
            p_allowed => 'NO',
            p_reason  => v_check
        );

        RAISE_APPLICATION_ERROR(-20001, 'Operation blocked: ' || v_check);
    END IF;
END BEFORE EACH ROW;


AFTER EACH ROW IS
BEGIN
    -- Add each row action to the list
    IF INSERTING THEN
        changed_rows.EXTEND;
        changed_rows(changed_rows.LAST) := 'Inserted row ID: ' || :NEW.sale_id;
    ELSIF UPDATING THEN
        changed_rows.EXTEND;
        changed_rows(changed_rows.LAST) := 'Updated row ID: ' || :NEW.sale_id;
    ELSIF DELETING THEN
        changed_rows.EXTEND;
        changed_rows(changed_rows.LAST) := 'Deleted row ID: ' || :OLD.sale_id;
    END IF;

    -- Also log each row as individual allowed entry
    IF v_allowed = 'YES' THEN
        log_action(
            p_user    => SYS_CONTEXT('USERENV','SESSION_USER'),
            p_action  => v_action,
            p_table   => 'SALES_HISTORY',
            p_allowed => 'YES',
            p_reason  => 'Row processed'
        );
    END IF;

END AFTER EACH ROW;


AFTER STATEMENT IS
BEGIN
    -- Log summary after the entire statement
    log_action(
        p_user    => SYS_CONTEXT('USERENV','SESSION_USER'),
        p_action  => 'STATEMENT-END',
        p_table   => 'SALES_HISTORY',
        p_allowed => v_allowed,
        p_reason  => 'Rows affected: ' || changed_rows.COUNT
    );
END AFTER STATEMENT;

END trg_sales_history_compound;

LAST PART TESTING :

--Trigger Blocks INSERT on Weekday (DENIED)
BEGIN
    INSERT INTO sales_history (sale_id, product_id, customer_id, sale_date, quantity_sold)
    VALUES (sales_seq.NEXTVAL, 1, 1, SYSDATE, 5);
END;


--Trigger Allows INSERT on Weekend (ALLOWED)
BEGIN
    INSERT INTO sales_history (sale_id, product_id, customer_id, sale_date, quantity_sold)
    VALUES (sales_seq.NEXTVAL, 1, 1, SYSDATE, 3);
END;


--Verify audit log:
SELECT username, action_type, allowed, reason, log_date
FROM audit_log
ORDER BY log_date DESC;

--Trigger Blocks INSERT on Holiday (DENIED)
INSERT INTO holidays (holiday_date, holiday_name)
VALUES (TRUNC(SYSDATE), 'TEST HOLIDAY');

COMMIT;
BEGIN
    INSERT INTO sales_history (sale_id, product_id, customer_id, sale_date, quantity_sold)
    VALUES (sales_seq.NEXTVAL, 1, 1, SYSDATE, 5);
END;
/

--Error Messages Are Clear

BEGIN
    INSERT INTO sales_history (sale_id, product_id, customer_id, sale_date, quantity_sold)
    VALUES (sales_seq.NEXTVAL, 1, 1, SYSDATE, 10);
END;
/

--User Info Correctly Recorded
SELECT username,
       action_type,
       allowed,
       reason,
       TO_CHAR(log_date, 'YYYY-MM-DD HH24:MI:SS') AS log_time
FROM audit_log
ORDER BY log_date DESC;



